#!/usr/bin/env python3
from accessoryFunctions.accessoryFunctions import printtime
from bin.blastn import BLASTn
from bin.tblastx import tBLASTx
from argparse import ArgumentParser
from time import time


if __name__ == '__main__':

    class Arguments(object):

        @staticmethod
        def parser_populate(parser):
            """
            Populates empty subparser with arguments. Keeps from having to use the same arguments several times
            in the code
            :param parser: Empty subparser object
            :return: Populated subparser object
            """
            parser.add_argument('--version',
                                action='version',
                                version='%(prog)')
            parser.add_argument('-s', '--sequencepath',
                                required=True,
                                help='Specify input fasta folder')
            parser.add_argument('-t', '--targetpath',
                                required=True,
                                help='Specify folder of targets')
            parser.add_argument('-r', '--reportpath',
                                required=True,
                                help='Specify output folder for csv')
            parser.add_argument('-c', '--cutoff',
                                type=int,
                                default=70, help='Minumum sequence identity threshold for a match to be reported')
            parser.add_argument('-e', '--evalue',
                                default='1E-5',
                                help='Minimum evalue to use for BLAST analyses')
            parser.add_argument('-n', '--numthreads',
                                type=int,
                                help='Specify number of threads')
            parser.add_argument('-a', '--align',
                                action='store_true',
                                help='Optionally output alignments of genes with less than 100% identity to reference '
                                     'genes. This alignment will use amino acid sequences for both query and reference')
            parser.add_argument('-u', '--unique',
                                action='store_true',
                                help='Do not report multiple hits at the same location in a contig. Instead, store the'
                                     'best hit, and ignore the rest')
            parser.add_argument('-R', '--resfinder',
                                action='store_true',
                                help='Perform ResFinder-like analyses ')
            parser.add_argument('-V', '--virulencefinder',
                                action='store_true',
                                help='Perform VirulenceFinder-like analyses')
            parser.add_argument('program')
            return parser

        def argument_object(self, parser):
            """
            Create an argument object from a populated subparser
            :param parser: Populated subparser
            :return: Argument object
            """
            # Create the arguments from the parser object
            args = parser.parse_args()
            # Set the analysis type based on the arguments provided
            if args.resfinder:
                args.analysistype = 'resfinder'
            elif args.virulencefinder:
                args.analysistype = 'virulence'
            # Warn that only one type of analysis can be perfomed at a time
            elif args.resfinder and args.virulencefinder:
                printtime('Cannot perform ResFinder and VirulenceFinder simultaneously. Please choose only one '
                          'of the -R and -v flags', self.start)
            # Default to geneseekr
            else:
                args.analysistype = 'geneseekr'
            # Add the start time variable to the object
            args.start = self.start
            return args

        def blastn_setup(self, subparser):
            """
            Populate empty subparser with arguments. Create arguments object from parser object. Send
            arguments object to BLASTn script
            :param subparser: Empty subparser
            """
            # Populate the specific subparser
            parser = self.parser_populate(subparser)
            # Create an argument object from the populated subparser
            args = self.argument_object(parser)
            # Run the analyses
            geneseekr = BLASTn(args)
            geneseekr.geneseekr()

        def tblastx_setup(self, subparser):
            """
            Populate empty subparser with arguments. Create arguments object from parser object. Send
            arguments object to BLASTx script
            :param subparser: Empty subparser
            """
            # Populate the specific subparser
            parser = self.parser_populate(subparser)
            # Create an argument object from the populated subparser
            args = self.argument_object(parser)
            # Run the analyses
            geneseekr = tBLASTx(args)
            geneseekr.geneseekr()

        def __init__(self, parser):
            """

            :param parser: Top level argument parser created to allow for error handling
            """
            # Start time
            self.start = time()
            # Create all the necessary subparsers
            subparsers = parser.add_subparsers(help='BLAST program to use. Options are:'
                                                    'BLASTn, BLASTp, tBLASTn, and tBLASTx')
            # BLASTn
            blastn_subparser = subparsers.add_parser(
                'blastn',
                help='Runs BLASTn (nucleotide against nucleotide')
            # BLASTp
            blastp_subparser = subparsers.add_parser(
                'blastp',
                help='Runs BLASTp (amino acid against amino acid')
            # tBLASTn
            tblastn_subparser = subparsers.add_parser(
                'tblastn',
                help='Runs tBLASTn (protein against translated nucleotide'
            )
            # tBLASTx
            tblastx_subparser = subparsers.add_parser(
                'tblastx',
                help='Runs tBLASTx (translated nucleotide against translated nucleotide')
            # Call the blast_setup method as the default action for the selected subparser
            # blastn_subparser.set_defaults(func=self.blastn_setup(blastn_subparser))
            tblastx_subparser.set_defaults(func=self.tblastx_setup(tblastx_subparser))


    # Run the class
    # # Because of issues with subparsers, if GeneSeekr -h is run on the command line, a TypeError occurs
    # create a simple parser with instructions on how to properly run the script
    argparser = ArgumentParser(
        description='Use to perform sequence alignments',
        usage='GeneSeekr [blastn/blastp/tblastn/tblastx] -s [sequence path] -t [target path] -r [report path]'
    )
    try:
        Arguments(argparser)
    except TypeError as e:
        if '%i format:' in str(e):
            argparser.parse_args()
        else:
            raise
# class PipelineInit(object):
#
#     def strainer(self):
#         for sample in self.runmetadata.samples:
#             if sample.general.bestassemblyfile != 'NA':
#                 setattr(sample, self.analysistype, GenObject())
#                 if self.genusspecific:
#                     try:
#                         genus = sample.general.closestrefseqgenus
#                     except AttributeError:
#                         genus = sample.general.referencegenus
#                     # Allow Shigella to use the same targets as Escherichia
#                     genus = genus if genus != 'Shigella' else 'Escherichia'
#                     targetpath = os.path.join(self.referencefilepath, self.analysistype, genus)
#                 else:
#                     targetpath = os.path.join(self.referencefilepath, self.analysistype)
#                 targets = glob(os.path.join(targetpath, '*.tfa'))
#                 targetcheck = glob(os.path.join(targetpath, '*.tfa'))
#                 if targetcheck:
#                     try:
#                         combinedtargets = glob(os.path.join(targetpath, '*.fasta'))[0]
#                     except IndexError:
#                         combinetargets(targets, targetpath)
#                         combinedtargets = glob(os.path.join(targetpath, '*.fasta'))[0]
#                     sample[self.analysistype].targets = targets
#                     sample[self.analysistype].combinedtargets = combinedtargets
#                     sample[self.analysistype].targetpath = targetpath
#                     sample[self.analysistype].targetnames = sequencenames(combinedtargets)
#                     sample[self.analysistype].reportdir = os.path.join(sample.general.outputdirectory,
#                                                                        self.analysistype)
#                 else:
#                     # Set the metadata file appropriately
#                     sample[self.analysistype].targets = 'NA'
#                     sample[self.analysistype].combinedtargets = 'NA'
#                     sample[self.analysistype].targetpath = 'NA'
#                     sample[self.analysistype].targetnames = 'NA'
#                     sample[self.analysistype].reportdir = 'NA'
#                     sample[self.analysistype].blastresults = 'NA'
#             else:
#                 # Set the metadata file appropriately
#                 setattr(sample, self.analysistype, GenObject())
#                 sample[self.analysistype].targets = 'NA'
#                 sample[self.analysistype].combinedtargets = 'NA'
#                 sample[self.analysistype].targetpath = 'NA'
#                 sample[self.analysistype].targetnames = 'NA'
#                 sample[self.analysistype].reportdir = 'NA'
#                 sample[self.analysistype].blastresults = 'NA'
#
#     def __init__(self, inputobject, analysistype, genusspecific, cutoff, unique):
#         self.runmetadata = inputobject.runmetadata
#         self.analysistype = analysistype
#         self.path = inputobject.path
#         self.start = inputobject.starttime
#         self.referencefilepath = inputobject.reffilepath
#         self.threads = inputobject.cpus
#         self.reportdir = inputobject.reportpath
#         self.cutoff = cutoff
#         self.logfile = inputobject.logfile
#         self.pipeline = True
#         self.genusspecific = genusspecific
#         self.align = False
#         self.unique = unique
#         # Get the alleles and profile into the metadata
#         self.strainer()
