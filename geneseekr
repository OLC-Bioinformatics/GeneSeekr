#!/usr/bin/env python3
from methods.geneseekr import modify_usage_error, objector
from bin.blastn import BLASTn as run_BLASTn
from bin.blastp import BLASTp as run_BLASTp
from bin.blastx import BLASTx as run_BLASTx
from bin.tblastn import tBLASTn as run_tBLASTn
from bin.tblastx import tBLASTx as run_tBLASTx
from time import time
import click
import sys

start = time()

# https://stackoverflow.com/a/40195800
click_options = [
    click.version_option(version='1.0.0'),
    click.option('-s', '--sequencepath',
                 required=True,
                 help='Specify input fasta folder'),
    click.option('-t', '--targetpath',
                 required=True,
                 help='Specify folder of targets'),
    click.option('-r', '--reportpath',
                 required=True,
                 help='Specify output folder for csv'),
    click.option('-c', '--cutoff',
                 type=int,
                 default=70, help='Minumum sequence identity threshold for a match to be reported'),
    click.option('-e', '--evalue',
                 default='1E-5',
                 help='Minimum evalue to use for BLAST analyses'),
    click.option('-n', '--numthreads',
                 type=int,
                 help='Specify number of threads'),
    click.option('-a', '--align',
                 is_flag=True,
                 help='Optionally output alignments of genes with less than 100% identity to reference '
                      'genes. This alignment will use amino acid sequences for both query and reference'),
    click.option('-u', '--unique',
                 is_flag=True,
                 help='Do not report multiple hits at the same location in a contig. Instead, store the '
                      'best hit, and ignore the rest')
]

click_nt_options = [
    click.option('-R', '--resfinder',
                 is_flag=True,
                 help='Perform ResFinder-like analyses'),
    click.option('-V', '--virulencefinder',
                 is_flag=True,
                 help='Perform VirulenceFinder-like analyses')
]


def add_options(options):
    def _add_options(func):
        for option in reversed(options):
            func = option(func)
        return func
    return _add_options


@click.group(context_settings=dict(help_option_names=['-h', '--help']))
def group():
    pass


@group.command()
@add_options(click_options)
@add_options(click_nt_options)
def blastn(**kwargs):
    """
    nt query: nt db
    """
    metadata = objector(kwargs, start)
    metadata.program = 'blastn'
    geneseekr = run_BLASTn(metadata)
    geneseekr.geneseekr()


@group.command()
@add_options(click_options)
def blastp(**kwargs):
    """
    protein query: protein db
    """
    metadata = objector(kwargs, start)
    metadata.program = 'blastp'
    geneseekr = run_BLASTp(metadata)
    geneseekr.geneseekr()


@group.command()
@add_options(click_options)
def blastx(**kwargs):
    """
    translated nt query: protein db
    """
    metadata = objector(kwargs, start)
    metadata.program = 'blastx'
    geneseekr = run_BLASTx(metadata)
    geneseekr.geneseekr()


@group.command()
@add_options(click_options)
@add_options(click_nt_options)
def tblastn(**kwargs):
    """
    protein query: translated nt db
    """
    metadata = objector(kwargs, start)
    metadata.program = 'tblastn'
    geneseekr = run_tBLASTn(metadata)
    geneseekr.geneseekr()


@group.command()
@add_options(click_options)
@add_options(click_nt_options)
def tblastx(**kwargs):
    """
    translated nt query: translated nt db
    """
    metadata = objector(kwargs, start)
    metadata.program = 'tblastx'
    geneseekr = run_tBLASTx(metadata)
    geneseekr.geneseekr()


def find_subcommand(subcommand_string):
    """
    Associate the appropriate function with the supplied BLAST program to use
    :param subcommand_string:
    :return:
    """
    if subcommand_string == 'blastn':
        subcommand = blastn
    elif subcommand_string == 'blastp':
        subcommand = blastp
    elif subcommand_string == 'blastx':
        subcommand = blastn
    elif subcommand_string == 'tblastn':
        subcommand = blastn
    else:
        subcommand = tblastx
    return subcommand


# Extract the BLAST command to use from the command line arguments
try:
    program = sys.argv[1] if sys.argv[1] in ['blastn', 'blastp', 'blastx', 'tblastn', 'tblastx'] else str()
except IndexError:
    program = str()

# Convert the program string to the appropriate subscommand to use when modifying the usage error - ResFinder
# and VirulenceFinder analyses are only available for BLAST programs that use a nt database
sub_command = find_subcommand(program)
# Change the default behaviour of click to print the help menu when a subcommand is specified, but is missing arguments
modify_usage_error(sub_command)

if __name__ == '__main__':
    group()


# class PipelineInit(object):
#
#     def strainer(self):
#         for sample in self.runmetadata.samples:
#             if sample.general.bestassemblyfile != 'NA':
#                 setattr(sample, self.analysistype, GenObject())
#                 if self.genusspecific:
#                     try:
#                         genus = sample.general.closestrefseqgenus
#                     except AttributeError:
#                         genus = sample.general.referencegenus
#                     # Allow Shigella to use the same targets as Escherichia
#                     genus = genus if genus != 'Shigella' else 'Escherichia'
#                     targetpath = os.path.join(self.referencefilepath, self.analysistype, genus)
#                 else:
#                     targetpath = os.path.join(self.referencefilepath, self.analysistype)
#                 targets = glob(os.path.join(targetpath, '*.tfa'))
#                 targetcheck = glob(os.path.join(targetpath, '*.tfa'))
#                 if targetcheck:
#                     try:
#                         combinedtargets = glob(os.path.join(targetpath, '*.fasta'))[0]
#                     except IndexError:
#                         combinetargets(targets, targetpath)
#                         combinedtargets = glob(os.path.join(targetpath, '*.fasta'))[0]
#                     sample[self.analysistype].targets = targets
#                     sample[self.analysistype].combinedtargets = combinedtargets
#                     sample[self.analysistype].targetpath = targetpath
#                     sample[self.analysistype].targetnames = sequencenames(combinedtargets)
#                     sample[self.analysistype].reportdir = os.path.join(sample.general.outputdirectory,
#                                                                        self.analysistype)
#                 else:
#                     # Set the metadata file appropriately
#                     sample[self.analysistype].targets = 'NA'
#                     sample[self.analysistype].combinedtargets = 'NA'
#                     sample[self.analysistype].targetpath = 'NA'
#                     sample[self.analysistype].targetnames = 'NA'
#                     sample[self.analysistype].reportdir = 'NA'
#                     sample[self.analysistype].blastresults = 'NA'
#             else:
#                 # Set the metadata file appropriately
#                 setattr(sample, self.analysistype, GenObject())
#                 sample[self.analysistype].targets = 'NA'
#                 sample[self.analysistype].combinedtargets = 'NA'
#                 sample[self.analysistype].targetpath = 'NA'
#                 sample[self.analysistype].targetnames = 'NA'
#                 sample[self.analysistype].reportdir = 'NA'
#                 sample[self.analysistype].blastresults = 'NA'
#
#     def __init__(self, inputobject, analysistype, genusspecific, cutoff, unique):
#         self.runmetadata = inputobject.runmetadata
#         self.analysistype = analysistype
#         self.path = inputobject.path
#         self.start = inputobject.starttime
#         self.referencefilepath = inputobject.reffilepath
#         self.threads = inputobject.cpus
#         self.reportdir = inputobject.reportpath
#         self.cutoff = cutoff
#         self.logfile = inputobject.logfile
#         self.pipeline = True
#         self.genusspecific = genusspecific
#         self.align = False
#         self.unique = unique
#         # Get the alleles and profile into the metadata
#         self.strainer()
